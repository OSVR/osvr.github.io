<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<title>
OSVR Developer Portal
</title>
<!-- all styles, including google web fonts -->
<link href="../../stylesheets/styles.css" rel="stylesheet" type="text/css" />
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-60529815-1', 'auto');
  ga('send', 'pageview');

</script>

</head>
<body>
<div class='container'>
<!-- static navbar -->
<nav class='navbar navbar-default'>
<div class='container-fluid'>
<div class='navbar-header'>
<button aria-controls='navbar' aria-expanded='false' class='navbar-toggle collapsed' data-target='#navbar' data-toggle='collapse' type='button'>
<span class='sr-only'>Toggle navigation</span>
<!-- Pretty sure this part makes the "hamburger menu" -->
<span class='icon-bar'></span>
<span class='icon-bar'></span>
<span class='icon-bar'></span>
</button>
<a class='navbar-brand' href='/'>
<img src="../../images/osvr-logo-menu.png" alt="Osvr logo menu" />
Developer Portal
</a>
</div>
<div class='navbar-collapse collapse' id='navbar'>
<ul class='nav navbar-nav navbar-right'>
<li class='dropdown'>
<a aria-expanded='false' class='dropdown-toggle' data-toggle='dropdown' href='#' role='button'>
Other OSVR Sites
<span class='caret'></span>
</a>
<ul class='dropdown-menu' role='menu'>
<li>
<!-- the query string excludes forks from this list, making it cleaner -->
<a href='https://github.com/OSVR?query=only%3Asources'>
GitHub Organization and OSVR Projects
</a>
</li>
<li>
<a href='https://waffle.io/osvr/osvr-core'>
OSVR issue tracker summary board on waffle.io
</a>
</li>
<li>
<a href='http://www.osvr.org/blog/'>
Dev Blog
</a>
</li>
<li>
<a href='http://support.osvr.com'>
Support Portal
</a>
</li>
<li class='divider'></li>
<li>
<a href='http://www.osvr.org'>
OSVR Home
</a>
</li>
</ul>
</li>
</ul>
<!-- google custom search -->
<script>
  (function() {
    var cx = '016285390483464504735:ifzwvrb3lp4';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!--<gcse:search></gcse:search>-->

<div class='navbar-nav navbar-right gcse-osvrnavbar'>
<gcse:search></gcse:search>
</div>
</div>
</div>
</nav>
<div class='container-fluid' id='page-content'>
<h1 id="an-introduction-to-osvr">An Introduction to OSVR</h1>

<p>Yuval Boger<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> and Ryan A. Pavlik<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>, December 2014, revised March 2015</p>

<h2 id="what-is-osvr">What is OSVR?</h2>

<p>OSVR™ is an open-source software platform for VR/AR applications.</p>

<p>OSVR provides an easy and standardized way to discover, configure and operate hundreds of devices: VR goggles, position trackers, depth cameras, game controllers and more. OSVR supports multiple operating systems, plugs into leading game engines and is freely available under a permissive Apache 2.0 license.</p>

<p>OSVR can be extended with open- or closed-source plugins. Plugins can provide support for new devices or add analysis capabilities such as a gesture engine, sensor fusion and data logging and eye tracking.</p>

<p>OSVR was started by experts in gaming and virtual reality and is supported by an ever-growing list of hardware vendors, game studios, universities and software companies.</p>

<p>This white paper provides a high-level overview of the motivation behind OSVR, its structure and key attributes.</p>

<h2 id="why-is-osvr-useful">Why is OSVR useful?</h2>

<p>Twenty years ago, if you wanted to print a document from WordPerfect, you needed to install the corresponding WordPerfect driver for your printer. Then, operating systems (such as Windows) introduced a standardized printer abstraction layer so that any Windows application could print to any printer that had a Windows driver.</p>

<p>OSVR standardizes the interface between input devices, games and output devices. It provides abstraction layers for VR devices and peripherals so that a game developer does not need to hardcode support for particular hardware. Instead, just like a Windows application prints to the Windows print services, the game developer connects to the OSVR abstraction layer. If a new VR goggle was introduced in 2016, an OSVR-based game published in 2015 could support this new goggle as soon as the goggle had an OSVR driver.</p>

<p>To a game developer, OSVR provides interfaces – pipes of data – as opposed to an API tied to a specific piece of hardware. If there are multiple devices that provide the same type of information (for instance: hand position), these devices can be interchanged. Today, you might get hand position from a Microsoft Kinect. Tomorrow, you might get hand position from a Razer Hydra. You can reconfigure the OSVR &quot;plumbing&quot; so that the game can continue to work well regardless of where hand position is coming from. With OSVR, game developers can focus on what they want to do with the data, as opposed to how to obtain it.</p>

<p>OSVR lets you mix and match hardware and software packages. For instance, if you use an eye tracking camera, you might use the software provided by the camera vendor to calculate gaze direction, but you might also use alternative gaze detection packages. This means that companies or research groups that focus on a particular software or hardware component (e.g. gaze detection module or eye tracking camera) are not left out of the VR eco-system: their expertise can be interconnected with components from others.</p>

<p>For <strong>game and application developers</strong> OSVR reduces risk:</p>

<ul>
<li>The developer no longer needs to choose a particular hardware or operating system target in advance.</li>
<li>Future friendly: the game can be used with newer devices that become available after the game was released</li>
<li>Development is faster because the developer focuses on the game rather than on interfacing with the hardware and because the developer has access to a wide range of analysis capabilities</li>
</ul>

<p>For <strong>hardware manufacturers</strong> OSVR:</p>

<ul>
<li>Provides a large collection of compelling applications that can use the new hardware as soon as an OSVR driver is written.</li>
<li>Solves the age-old chicken-and-egg dilemma of &quot;without installed base, no games; without games, no installed base&quot;.</li>
<li>Eliminates the need to directly integrate with game developers; writing an OSVR plugin is often sufficient.</li>
<li>Provides access to analysis plugins that make the hardware more useful.</li>
</ul>

<p>For <strong>software developers</strong> OSVR provides the ability to:</p>

<ul>
<li>Test and demonstrate their software modules in the context of a full pre-existing VR stack such as a published game. For instance, if a new position tracking algorithm is developed, OSVR could be configured to use this new algorithm instead of preexisting ones.</li>
<li>Apply their IP (e.g. gesture engine) to a wide range of sensing devices and applications</li>
<li>Use open- or closed-source modules</li>
</ul>

<p>For <strong>end users</strong> OSVR provides freedom and choice, promotes innovation through its open design and eliminates the dependency on any single vendor.</p>

<h2 id="high-level-osvr-architecture">High-level OSVR Architecture</h2>

<p>The diagram below shows the conceptual architecture for OSVR.</p>

<p><img alt="High level overview" src="high-level-overview.png" /></p>

<p><strong>Applications</strong> written on game engines can interact with OSVR via dedicated game engine plugins. Alternatively, an application can directly access the OSVR &quot;ClientKit&quot; interface.</p>

<p><strong>Analysis plugins</strong> are software modules that convert data from lower-level device plugins into higher-level information. For instance, a gesture engine plugin can convert a stream of XYZ coordinates to a recognized gesture.</p>

<p><strong>Device plugins</strong> connect to physical devices and expose interfaces – pipes of data – to higher layers. For instance, a plugin for a VR goggle can expose a display interface as well as an orientation tracker interface corresponding to an embedded head-tracker. Many device types and dozens of devices are supported.</p>

<p>The <strong>adaptation layer</strong> provides OS-specific implementation (e.g. Android vs. Windows vs. iOS) as well as allows OSVR devices to be accessed through a network interface such as WiFi or Bluetooth.</p>

<p>The <strong>management layer</strong> stores and loads system and user-specific configuration locally and in the cloud. It also provides services to download device plugins on-demand, detect when software updates are available and other utility functions.</p>

<p>Source code and well-defined interfaces are provided for all these components. Device and analysis plugins can easily be added by interested parties, and examples of how to do so are provided as part of the OSVR source-code distribution.</p>

<h2 id="osvr-technical-concepts">OSVR Technical Concepts</h2>

<p>Prior to explaining how applications interface with OSVR and how to write plugins for OSVR, we need to touch on a few OSVR technical concepts:</p>

<p>A <strong>device</strong> is a physical entity such as an orientation sensor or the Razer Hydra controller.</p>

<p>An <strong>interface</strong> is a pipe of data. A device exposes one or more interfaces. For instance, a Razer Hydra controller exposes several interfaces:</p>

<ul>
<li>Two XYZ position interfaces (one for the left hand, one for the right)</li>
<li>Two orientation interfaces (one for the left hand, one for the right)</li>
<li>Two buttons sets, one for each hand</li>
<li>A set of analog interfaces for the variable-position triggers and joysticks</li>
</ul>

<p>An <em>interface</em> is an instance of an <strong>interface class.</strong> An interface class defines properties that can be set or queried as well as a set of events that the class generates. A property might be the last obtained XYZ position from an XYZ position interface. An event could be the press of a particular button in a button set interface.</p>

<p>A <strong>plugin</strong> is a software module that can be dynamically identified, loaded and connected to OSVR. Drivers contained in plugins implement <em>interface classes</em>. There are two types of drivers in plugins:</p>

<ul>
<li>Device pluginsthat implement interfaces for one or more physical devices</li>
<li>Analysis plugins that implement interfaces, such as gesture engines, that do not connect directly to devices. For instance, a data smoothing plugin receives data from a device interface and converts it into smoothed data. A face detection plugin receives images from a camera interface and can generate an event when a face has been identified.</li>
</ul>

<p>From the OSVR perspective, both types of plugins are identical, and the distinction is made for human consumption.</p>

<h2 id="osvr-resource-naming">OSVR Resource Naming</h2>

<p>OSVR maintains a &quot;path tree&quot; – similar to a URL or file system path – in which all the sensing and rendering data is made available. Aliases are configured in the server to essentially redirect from a semantic path (a path with a meaningful name) all the way back to the system-specific hardware details. Thus, while direct device access by name is possible, it is not recommended: instead, we recommend accessing semantic paths. This accommodates use cases where the hardware is not immediately available at startup or is changed during operation without any impact to the application developer. Some examples:</p>

<ul>
<li>A path capable of position, orientation, or pose (position and orientation) callbacks or state access, associated with the left hand: <code>/me/hands/left</code></li>
<li>Position of the &quot;0&quot; controller of the Hydra, directly accessed in the namespace of the <code>com.osvr.bundled.Multiserver</code> plugin: <code>/com_osvr_bundled_Multiserver/RazerHydra0/position/0</code></li>
<li>Output of the first smoothing filter in a hypothetical org.example.smoothing plugin: <code>/org_example_smoothing/smooth_filter/0</code></li>
</ul>

<p>Just like a game allows mapping of various buttons to various game actions, OSVR allows defining the connection between interfaces, analysis plugins and actions. For instance:</p>

<ul>
<li><code>/joystick/button/1</code> → <code>/actions/fire</code> maps the first joystick button into a fire action. While the game could choose to access <code>/joystick/button/1</code> directly, it is recommended to access <code>/actions/fire</code> in this example because this allows changing the flow of information from the hardware through the OSVR layers without changing the game itself.</li>
<li><code>/com_osvr_bundled_Multiserver/RazerHydra0/position/0</code> → <code>/org_example_smoothing/smooth_filter/0</code> → <code>/me/hands/left</code> specifies that the position of the first Hydra controller goes through a smoothing filter and then is mapped to the left hand.</li>
</ul>

<p>The connection between interfaces can be pre-loaded or can be changed dynamically. <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></p>

<p>The list of available resources is specified in JSON files as part of the OSVR distribution and is part of the OSVR documentation.</p>

<h2 id="synchronous-and-asynchronous-calls">Synchronous and Asynchronous Calls</h2>

<p>An application can communicate with a plugin in two ways:</p>

<ul>
<li>Synchronous (&quot;blocking&quot;) calls. These query the particular <em>state</em> of a parameter.</li>
<li>Asynchronous calls (&quot;callbacks&quot;). An application can register to receive a <em>callback</em> for a particular event such as a button press, a new face being detected and so forth.</li>
</ul>

<p>An application can use either or both methods. For instance, some applications much choose to query the orientation tracker state in the main loop using a synchronous call whereas they might register for callbacks on certain game controller button presses. Please see examples in the OSVR documentation.</p>

<h2 id="osvr-for-game-developers">OSVR for Game Developers</h2>

<p>There are three pieces of a minimal application:</p>

<ul>
<li>Initialize the library, providing an application ID, and receiving a &quot;client context&quot; which must be passed to future calls.</li>
<li>In your application main loop, call the update method, which triggers callbacks and handled state changes.</li>
<li>During application shutdown, shutdown the library (providing the client context).</li>
</ul>

<p>These are illustrated in the message state diagram below:</p>

<p><img alt="Base game flow" src="base-game-flow.png" /></p>

<p>Of course, such an application doesn&#39;t really use OSVR in a very productive sense. A sample flow of a more realistic application would also:</p>

<ul>
<li><p>Probably before the main loop starts:</p>

<ul>
<li>Get some interfaces,</li>
<li>Register callbacks if desired on interfaces.</li>
<li>Get display parameter data.</li>
</ul></li>
<li><p>During main loop:</p>

<ul>
<li>Handle data received by callbacks, if any.</li>
<li>Read state of interfaces, if desired</li>
</ul></li>
<li><p>During application shutdown, shutdown the library (providing the client context).</p></li>
</ul>

<p>These are illustrated in the message state diagram below:</p>

<p><img alt="Fuller game flow" src="fuller-game-flow.png" /></p>

<h2 id="osvr-for-plugin-developers">OSVR for Plugin Developers</h2>

<p>Device and analysis plugins are dynamically loaded by OSVR. Plugins provide support for new types of hardware or analysis functions such as gesture engines.</p>

<p>The OSVR documentation contains example plugins. If you are a hardware or software developer that wants to create an OSVR plugin, please contact us for additional details.</p>

<p>To support a new game engine beyond those already supported in OSVR, the best place to start is &quot;OSVR for game developers&quot; since from an OSVR perspective, a game engine is an application that uses OSVR rather than an OSVR plugin.</p>

<h2 id="osvr-roadmap">OSVR Roadmap</h2>

<p>As an open-source project, the OSVR community will have a very strong influence on future directions. At present, planned improvements include the following:</p>

<ul>
<li>Enhance the rendering side of OSVR to offer comprehensive support for rendering to multiple types of HMDs and other display devices.</li>
<li>Create additional device plugins for new hardware as well as analysis plugins.</li>
<li>Create additional operating system ports beyond Windows and Android.</li>
</ul>

<p>We are excited to work with you and see what we can build together with OSVR!</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Yuval Boger is the CEO of Sensics. Sensics is the founding contributor of OSVR.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Ryan A. Pavlik is a senior software engineer at Sensics.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Dynamic connection changes are not yet implemented as of Dec 2014.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js'></script>
<script src="../../javascripts/all.js" type="text/javascript"></script>
<hr>
<div class='footer'>
<div class='container'>
<p>Copyright 2014&ndash;2016 OSVR contributors. See individual projects for applicable license notices.</p>
<p>
Please consider supporting the OSVR movement by
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=X5L7QVZBPT2F6">donating to OSVR</a>
.
</p>

<p class='text-muted'>
<small>
Source code (access requires authorization) at
<a href='https://github.com/OSVR/OSVR.github.io'>
https://github.com/OSVR/OSVR.github.io
</a>
<br>
<!-- - This part commented out because it doesn't take into consideration data files. -->
<!-- - Page last updated -->
<!-- - = `git log -1 --format="%aD" -- /home/jenkins/workspace/OSVR-github-io/source/whitepapers/introduction_to_osvr/index.html.md` -->
Site generated/compiled
Fri, 20 Apr 2018 11:45:02 +0000
from commit
<a href='https://github.com/OSVR/OSVR.github.io/commit/d3f678a
'>
d3f678a

</a>
</small>
</p>
</div>
</div>
<!-- Start of OSVR Zendesk Widget script -->
<script>/*<![CDATA[*/window.zEmbed||function(e,t){var n,o,d,i,s,a=[],r=document.createElement("iframe");window.zEmbed=function(){a.push(arguments)},window.zE=window.zE||window.zEmbed,r.src="javascript:false",r.title="",r.role="presentation",(r.frameElement||r).style.cssText="display: none",d=document.getElementsByTagName("script"),d=d[d.length-1],d.parentNode.insertBefore(r,d),i=r.contentWindow,s=i.document;try{o=s}catch(c){n=document.domain,r.src='javascript:var d=document.open();d.domain="'+n+'";void(0);',o=s}o.open()._l=function(){var o=this.createElement("script");n&&(this.domain=n),o.id="js-iframe-async",o.src=e,this.t=+new Date,this.zendeskHost=t,this.zEQueue=a,this.body.appendChild(o)},o.write('<body onload="document._l();">'),o.close()}("//assets.zendesk.com/embeddable_framework/main.js","osvr.zendesk.com");/*]]>*/</script>
<!-- End of OSVR Zendesk Widget script -->

</div>
</body>
</html>
